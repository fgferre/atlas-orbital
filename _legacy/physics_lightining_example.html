<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eclipse Lunar: Renderização Ultra-Realista</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Helvetica Neue", Arial, sans-serif;
      }

      /* Container para o 3D */
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1; /* Fica atrás da UI */
      }

      /* UI Elegante e Minimalista */
      #ui-layer {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 10;
      }

      .hud-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.8rem;
        background: linear-gradient(
          90deg,
          rgba(0, 0, 0, 0.8) 0%,
          rgba(0, 0, 0, 0) 100%
        );
        padding: 15px;
        border-left: 2px solid #ff4d4d;
        pointer-events: none;
        z-index: 10;
      }

      h1 {
        margin: 0;
        font-weight: 200;
        font-size: 1.4rem;
        letter-spacing: 2px;
        text-transform: uppercase;
      }
      .sub {
        font-size: 0.7rem;
        color: #888;
        margin-bottom: 10px;
        display: block;
      }

      button {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        padding: 10px 20px;
        border-radius: 30px;
        backdrop-filter: blur(10px);
        cursor: pointer;
        text-transform: uppercase;
        font-size: 0.7rem;
        letter-spacing: 1px;
        transition: all 0.3s ease;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: white;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
      }
      button.active {
        background: #ff4d4d;
        border-color: #ff4d4d;
        color: black;
        font-weight: bold;
      }

      #loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ff4d4d;
        font-family: monospace;
        z-index: 999;
        transition: opacity 1s ease;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="loading">INICIALIZANDO RENDERIZADOR PBR...</div>

    <!-- Container adicionado para corrigir o erro -->
    <div id="canvas-container"></div>

    <div class="hud-panel">
      <h1>Sistema Solar</h1>
      <span class="sub">SIMULAÇÃO FÍSICA DE LUZ</span>
      <div id="telemetry">Status: Orbital<br />Iluminação: Direta</div>
    </div>

    <div id="ui-layer">
      <button onclick="setCamera('earth')">Terra</button>
      <button onclick="setCamera('moon')">Lua</button>
      <button onclick="toggleEclipse()" id="btn-eclipse">
        Simular Eclipse
      </button>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import {
        Lensflare,
        LensflareElement,
      } from "three/addons/objects/Lensflare.js";

      // --- SHADERS PERSONALIZADOS (A Mágica do Realismo) ---

      // 1. Shader do Sol (Plasma Procedural)
      const sunVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const sunFragmentShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vNormal;

            // Simplex Noise básico
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                float noiseVal = snoise(vec3(vNormal * 4.0 + time * 0.2));
                float noiseVal2 = snoise(vec3(vNormal * 8.0 - time * 0.3));
                
                vec3 colorHot = vec3(1.0, 0.9, 0.4); // Amarelo brilhante
                vec3 colorCool = vec3(1.0, 0.4, 0.0); // Laranja escuro
                
                float mixVal = (noiseVal + noiseVal2) * 0.5 + 0.5;
                vec3 finalColor = mix(colorCool, colorHot, mixVal);
                
                // Brilho na borda (Fresnel invertido para o sol)
                float glow = pow(0.7 - dot(vNormal, vec3(0,0,1)), 3.0);
                
                gl_FragColor = vec4(finalColor + glow * vec3(1.0, 0.6, 0.2), 1.0);
            }
        `;

      // 2. Shader da Atmosfera (Realista)
      const atmosVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

      const atmosFragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            uniform vec3 lightVector; // Vetor direcional da luz
            
            void main() {
                // Cálculo de intensidade baseado na visão (Fresnel)
                float viewIntensity = pow(0.55 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                
                // Atmosfera só brilha onde há luz do sol (Day side)
                // Mas no eclipse, precisamos que ela brilhe nas bordas mesmo no escuro? 
                // Para simplificar e manter a beleza:
                
                // Cor azulada padrão da atmosfera
                vec3 atmosColor = vec3(0.2, 0.5, 1.0); 
                
                gl_FragColor = vec4(atmosColor, 1.0) * viewIntensity;
            }
        `;

      // --- SETUP PRINCIPAL ---

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        40,
        window.innerWidth / window.innerHeight,
        0.1,
        3000
      );

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Otimização para telas Retina
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
      // PBR Setup
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      // CORREÇÃO: Agora o elemento existe no HTML
      const container = document.getElementById("canvas-container");
      if (container) {
        container.appendChild(renderer.domElement);
      } else {
        console.error(
          "ERRO CRÍTICO: Container #canvas-container não encontrado no DOM."
        );
        document.body.appendChild(renderer.domElement); // Fallback
      }

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // --- CARREGAMENTO DE TEXTURAS (Mapas Normais e Especulares) ---

      const texLoader = new THREE.TextureLoader();
      const load = (url) => texLoader.load(url);

      // URLs de alta qualidade (NASA/Comunidade)
      const earthDayMap = load(
        "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg"
      );
      const earthNormalMap = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg"
      );
      const earthSpecularMap = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg"
      );
      const earthCloudsMap = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png"
      );
      const moonColorMap = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg"
      );
      // Usando o mesmo mapa de cor como bump/normal para lua por falta de normal map dedicado limpo na CDN, funciona bem para crateras

      // Lens Flare Assets
      const textureFlare0 = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
      );
      const textureFlare3 = load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare3.png"
      );

      THREE.DefaultLoadingManager.onLoad = () => {
        const loading = document.getElementById("loading");
        if (loading) {
          loading.style.opacity = "0";
          setTimeout(() => loading.remove(), 1000);
        }
      };

      // --- CRIAÇÃO DOS OBJETOS ---

      // 1. Sol (Shader Mesh + Luz)
      const sunGeo = new THREE.SphereGeometry(15, 64, 64);
      const sunMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: sunVertexShader,
        fragmentShader: sunFragmentShader,
        side: THREE.DoubleSide,
      });
      const sun = new THREE.Mesh(sunGeo, sunMat);
      sun.position.set(-200, 0, 0); // Longe
      scene.add(sun);

      // Luz Direcional Principal
      const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
      sunLight.position.copy(sun.position);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 4096;
      sunLight.shadow.mapSize.height = 4096;
      sunLight.shadow.camera.near = 0.5;
      sunLight.shadow.camera.far = 500;
      // Ajuste o frustum da sombra para cobrir a Terra e Lua
      const d = 50;
      sunLight.shadow.camera.left = -d;
      sunLight.shadow.camera.right = d;
      sunLight.shadow.camera.top = d;
      sunLight.shadow.camera.bottom = -d;
      sunLight.shadow.bias = -0.0001;
      scene.add(sunLight);

      // Lens Flare
      const lensflare = new Lensflare();
      lensflare.addElement(
        new LensflareElement(textureFlare0, 600, 0, sunLight.color)
      );
      lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
      lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
      lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
      lensflare.addElement(new LensflareElement(textureFlare3, 70, 1.0));
      sunLight.add(lensflare);

      // 2. Grupo Terra
      const earthGroup = new THREE.Group();
      scene.add(earthGroup);

      // Terra PBR
      const earthMat = new THREE.MeshPhongMaterial({
        map: earthDayMap,
        normalMap: earthNormalMap,
        normalScale: new THREE.Vector2(0.85, 0.85),
        specularMap: earthSpecularMap,
        specular: new THREE.Color(0x222222),
        shininess: 25,
      });
      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(10, 64, 64),
        earthMat
      );
      earth.castShadow = true;
      earth.receiveShadow = true;
      earthGroup.add(earth);

      // Nuvens
      const cloudMat = new THREE.MeshStandardMaterial({
        map: earthCloudsMap,
        transparent: true,
        opacity: 0.8,
        blending: THREE.NormalBlending,
        side: THREE.DoubleSide,
        alphaTest: 0.1,
      });
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(10.15, 64, 64),
        cloudMat
      );
      clouds.castShadow = true;
      earthGroup.add(clouds);

      // Atmosfera Shader
      const atmosMat = new THREE.ShaderMaterial({
        vertexShader: atmosVertexShader,
        fragmentShader: atmosFragmentShader,
        uniforms: { lightVector: { value: new THREE.Vector3(1, 0, 0) } },
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.3,
      });
      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(10.8, 64, 64),
        atmosMat
      );
      earthGroup.add(atmosphere);

      // 3. Lua
      const moonGroup = new THREE.Group();
      earthGroup.add(moonGroup);

      // Material da Lua com capacidade de mudar de cor (tint)
      const moonMat = new THREE.MeshStandardMaterial({
        map: moonColorMap,
        bumpMap: moonColorMap, // Reutilizando para relevo
        bumpScale: 0.05,
        roughness: 0.9,
        metalness: 0.0,
        color: 0xffffff,
      });
      const moon = new THREE.Mesh(
        new THREE.SphereGeometry(2.7, 64, 64),
        moonMat
      );
      moon.castShadow = true;
      moon.receiveShadow = true;
      moon.position.set(60, 0, 0); // Distância orbital
      moonGroup.add(moon);

      // 4. Campo Estelar (Starfield) Otimizado
      const starsGeo = new THREE.BufferGeometry();
      const count = 5000;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const colorPalette = [
        new THREE.Color(0xffffff),
        new THREE.Color(0xaaaaff),
        new THREE.Color(0xffddaa),
      ];

      for (let i = 0; i < count; i++) {
        const r = 800 + Math.random() * 800; // Distância
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);

        const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      starsGeo.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      starsGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      const starsMat = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
      });
      const starField = new THREE.Points(starsGeo, starsMat);
      scene.add(starField);

      // --- POST-PROCESSING (Bloom Cinematic) ---
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.85
      );
      bloomPass.threshold = 0.5; // Só brilha o que é muito claro (Sol e reflexos)
      bloomPass.strength = 1.0;
      bloomPass.radius = 0.8;
      composer.addPass(bloomPass);

      // --- LÓGICA DE SIMULAÇÃO ---

      let state = {
        animating: true,
        eclipseMode: false,
        moonAngle: 0,
        orbitSpeed: 0.005,
      };

      // Posição inicial
      camera.position.set(20, 10, 50);
      controls.target.copy(earth.position);

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        // Anima Shader do Sol
        sunMat.uniforms.time.value = elapsed;

        if (state.animating) {
          // Rotações
          earth.rotation.y += 0.001;
          clouds.rotation.y += 0.0012;
          moon.rotation.y += 0.005;

          // Órbita da Lua
          state.moonAngle += state.orbitSpeed;

          // Se estiver em modo eclipse, trava o eixo Y para garantir alinhamento
          // Se não, dá uma inclinação orbital para realismo (5 graus)
          const inclination = state.eclipseMode
            ? 0
            : Math.sin(state.moonAngle * 2) * 5;

          moon.position.x = Math.cos(state.moonAngle) * 60;
          moon.position.z = Math.sin(state.moonAngle) * 60;
          moon.position.y = inclination;

          // Cálculo da "Lua de Sangue"
          // Calculamos o quanto a Lua está "atrás" da Terra em relação ao Sol
          // Sol está em -200, Terra em 0. Vetor Sol->Terra é (1, 0, 0)
          // Lua precisa estar em (+X) para eclipse

          const sunDir = new THREE.Vector3(1, 0, 0); // Normalizado
          const earthToMoon = moon.position.clone().normalize();
          const alignment = sunDir.dot(earthToMoon); // 1.0 = Perfeitamente atrás da Terra

          // Se o alinhamento for > 0.99 (quase perfeito atrás), a lua fica vermelha
          // O efeito começa suavemente a partir de 0.95
          if (alignment > 0.95 && Math.abs(moon.position.y) < 2) {
            // Estamos na sombra
            const factor = (alignment - 0.95) * 20; // 0 a 1
            const bloodColor = new THREE.Color(0xff2200); // Vermelho escuro
            const normalColor = new THREE.Color(0xffffff);

            // Interpolação da cor (Lerp)
            moonMat.color.lerpColors(
              normalColor,
              bloodColor,
              Math.min(factor, 1.0)
            );
            // Diminui a luz recebida para simular sombra (metalness hack ou emissive hack)
            moonMat.emissive = new THREE.Color(0x330500).multiplyScalar(
              Math.min(factor, 0.5)
            );

            if (factor > 0.8) updateTelemetry("ECLIPSE TOTAL (UMBRA)");
            else updateTelemetry("ECLIPSE PARCIAL (PENUMBRA)");
          } else {
            // Lua normal
            moonMat.color.setHex(0xffffff);
            moonMat.emissive.setHex(0x000000);
            updateTelemetry("Lua Cheia / Orbital");
          }
        }

        controls.update();
        composer.render();
      }

      // --- CONTROLES DA UI ---

      function updateTelemetry(text) {
        document.getElementById("telemetry").innerText = `Status: ${text}`;
        if (text.includes("ECLIPSE")) {
          document.querySelector(".hud-panel").style.borderLeftColor =
            "#ff0000";
        } else {
          document.querySelector(".hud-panel").style.borderLeftColor =
            "#4facfe";
        }
      }

      window.toggleEclipse = function () {
        const btn = document.getElementById("btn-eclipse");

        if (state.eclipseMode) {
          // Sair do eclipse
          state.eclipseMode = false;
          state.orbitSpeed = 0.005; // Volta ao normal
          btn.classList.remove("active");
          btn.innerText = "Simular Eclipse";
          camera.position.set(20, 10, 50);
          controls.target.set(0, 0, 0);
        } else {
          // Entrar no eclipse
          state.eclipseMode = true;
          state.orbitSpeed = 0.001; // Câmera lenta
          state.moonAngle = -0.2; // Um pouco antes do eclipse começar
          btn.classList.add("active");
          btn.innerText = "Reiniciar Órbita";

          // Câmera cinematográfica atrás da Lua
          const start = { x: 75, y: 2, z: 5 }; // Posição atrás da lua
          camera.position.set(start.x, start.y, start.z);
          controls.target.set(0, 0, 0); // Olhando para Terra/Sol
        }
      };

      window.setCamera = function (target) {
        if (target === "earth") {
          camera.position.set(20, 5, 20);
          controls.target.set(0, 0, 0);
        } else if (target === "moon") {
          // Apenas aproxima, o controle orbital permite mover
          const pos = moon.position.clone();
          camera.position.set(pos.x + 5, pos.y + 2, pos.z + 5);
          controls.target.copy(pos);
        }
      };

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
