diff --git a/src/components/canvas/Planet.tsx b/src/components/canvas/Planet.tsx
index 49f767a..42ba5de 100644
--- a/src/components/canvas/Planet.tsx
+++ b/src/components/canvas/Planet.tsx
@@ -9,16 +9,49 @@ import {
 } from "../../lib/astrophysics";
 import { useStore } from "../../store";
 import { ErrorBoundary } from "../utils/ErrorBoundary";
-import { Earth } from "./Earth";
 import { SOLAR_SYSTEM_BODIES } from "../../data/celestialBodies";
 import { PlanetModel } from "./PlanetModel";
 
+// import { cloudVertexShader, cloudFragmentShader } from "./shaders/cloudShader";
+import {
+  atmosphereVertexShader,
+  atmosphereFragmentShader,
+} from "./shaders/atmosphereShader";
+import {
+  ringShadowVertexPatch,
+  ringShadowFragmentPatch,
+} from "./shaders/ringShadowShader";
+import {
+  planetShadowVertexPatch,
+  planetShadowFragmentPatch,
+  planetShadowEmissivePatch,
+} from "./shaders/planetShadowShader";
+
 interface PlanetProps {
   body: CelestialBody;
   children?: React.ReactNode;
+  roughness: number;
+  metalness: number;
+  sunEmissive: number;
+  ringEmissive: number;
+  ringShadowIntensity: number;
 }
 
-const PlanetVisual = ({ body }: { body: CelestialBody }) => {
+const PlanetVisual = ({
+  body,
+  roughness,
+  metalness,
+  sunEmissive,
+  ringEmissive,
+  ringShadowIntensity,
+}: {
+  body: CelestialBody;
+  roughness: number;
+  metalness: number;
+  sunEmissive: number;
+  ringEmissive: number;
+  ringShadowIntensity: number;
+}) => {
   const groupRef = useRef<THREE.Group>(null);
   const rotationRef = useRef<THREE.Group>(null);
   const selectId = useStore((state) => state.selectId);
@@ -42,36 +75,40 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
     textureMap = useTexture(body.textures.map);
   }
 
-  // Custom Shader for Clouds (treating black as transparent)
+  // Cloud Material (PBR + Analytical Shadows)
   const cloudMaterial = useMemo(() => {
     if (!textureClouds) return null;
-    return new THREE.ShaderMaterial({
-      uniforms: {
-        map: { value: textureClouds },
-      },
-      vertexShader: `
-        varying vec2 vUv;
-        void main() {
-          vUv = uv;
-          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
-        }
-      `,
-      fragmentShader: `
-        uniform sampler2D map;
-        varying vec2 vUv;
-        void main() {
-          vec4 texColor = texture2D(map, vUv);
-          // Use the brightness (red channel) as alpha
-          // Clouds are white, background is black.
-          gl_FragColor = vec4(1.0, 1.0, 1.0, texColor.r); 
-        }
-      `,
+    const mat = new THREE.MeshStandardMaterial({
+      map: textureClouds,
       transparent: true,
-      blending: THREE.NormalBlending,
+      blending: THREE.AdditiveBlending,
       side: THREE.DoubleSide,
       depthWrite: false, // Don't write to depth buffer to avoid occlusion issues
+      roughness: 1.0,
+      metalness: 0.0,
     });
-  }, [textureClouds]);
+
+    mat.onBeforeCompile = (shader) => {
+      mat.userData.shader = shader;
+      shader.uniforms.uSunPosition = { value: new THREE.Vector3(0, 0, 0) };
+      shader.uniforms.uShadowIntensity = { value: ringShadowIntensity };
+
+      // Inject uniforms and varying
+      shader.vertexShader = `
+        varying vec3 vPos;
+        ${shader.vertexShader}
+      `.replace("#include <begin_vertex>", planetShadowVertexPatch);
+
+      shader.fragmentShader = `
+        uniform vec3 uSunPosition;
+        uniform float uShadowIntensity;
+        varying vec3 vPos;
+        ${shader.fragmentShader}
+      `.replace("#include <map_fragment>", planetShadowFragmentPatch);
+    };
+
+    return mat;
+  }, [textureClouds, ringShadowIntensity]);
 
   useEffect(() => {
     return () => {
@@ -86,27 +123,8 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
         color: { value: new THREE.Color(0x00aaff) },
         viewVector: { value: new THREE.Vector3(0, 0, 0) },
       },
-      vertexShader: `
-        varying vec3 vNormal;
-        varying vec3 vViewPosition;
-        void main() {
-          vNormal = normalize(normalMatrix * normal);
-          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
-          vViewPosition = -mvPosition.xyz;
-          gl_Position = projectionMatrix * mvPosition;
-        }
-      `,
-      fragmentShader: `
-        uniform vec3 color;
-        varying vec3 vNormal;
-        varying vec3 vViewPosition;
-        void main() {
-          vec3 normal = normalize(vNormal);
-          vec3 viewDir = normalize(vViewPosition);
-          float intensity = pow(0.6 - dot(normal, viewDir), 4.0);
-          gl_FragColor = vec4(color, intensity);
-        }
-      `,
+      vertexShader: atmosphereVertexShader,
+      fragmentShader: atmosphereFragmentShader,
       transparent: true,
       blending: THREE.AdditiveBlending,
       side: THREE.BackSide, // Render on the inside of a slightly larger sphere
@@ -120,16 +138,16 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
     };
   }, [atmosphereMaterial]);
 
-  // Analytical Ring Shadow Logic
+  // Analytical Ring Shadow Logic & Earth Night Lights
   const planetMaterial = useMemo(() => {
     const mat = new THREE.MeshStandardMaterial({
       map: textureMap,
       color: textureMap ? "#ffffff" : body.color,
       emissive: body.type === "star" ? body.color : "#000",
       emissiveMap: body.type === "star" ? textureMap : null,
-      emissiveIntensity: body.type === "star" ? 1.2 : 0,
-      roughness: 1.0,
-      metalness: 0.1,
+      emissiveIntensity: body.type === "star" ? sunEmissive : 0,
+      roughness: roughness,
+      metalness: metalness,
     });
 
     // Apply shaders: ring shadows for ringed planets
@@ -147,16 +165,9 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
         // Inject uniforms and varying
         shader.vertexShader = `
           varying vec3 vPos;
-          varying vec3 vObjectNormal;
+          varying vec3 vLocalNormal;
           ${shader.vertexShader}
-        `.replace(
-          "#include <begin_vertex>",
-          `
-          #include <begin_vertex>
-          vPos = position;
-          vObjectNormal = normal;
-          `
-        );
+        `.replace("#include <begin_vertex>", ringShadowVertexPatch);
 
         shader.fragmentShader = `
           uniform sampler2D tRing;
@@ -164,52 +175,23 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
           uniform float uInnerRadius;
           uniform float uOuterRadius;
           varying vec3 vPos;
-          varying vec3 vObjectNormal;
+          varying vec3 vLocalNormal;
           ${shader.fragmentShader}
-        `.replace(
-          "#include <map_fragment>",
-          `
-          #include <map_fragment>
-
-          // Analytical Ring Shadow
-          // Ray from fragment (vPos) to Sun (uSunPosition)
-          vec3 lightDir = normalize(uSunPosition - vPos);
-
-          // Check if surface faces the sun (Day side)
-          // We only cast shadows on the lit side.
-          float sunDot = dot(normalize(vObjectNormal), lightDir);
-
-          // Smoothly fade out the shadow effect as we approach the terminator (day/night line)
-          // This prevents hard artifacts at the shadow edge near the dark side.
-          float terminatorFade = smoothstep(0.0, 0.2, sunDot);
-
-          if (terminatorFade > 0.0) {
-            // Intersect with Ring Plane (y=0)
-            // t = -origin.y / dir.y
-            float t = -vPos.y / lightDir.y;
-
-            // If t > 0, the ray hits the plane *towards* the sun (shadow caster)
-            if (t > 0.0) {
-              vec3 hitPos = vPos + lightDir * t;
-              float radius = length(hitPos.xz);
-
-              if (radius > uInnerRadius && radius < uOuterRadius) {
-                float u = (radius - uInnerRadius) / (uOuterRadius - uInnerRadius);
-                vec4 ringColor = texture2D(tRing, vec2(u, 0.5));
-
-                // Darken based on ring opacity and terminator fade
-                // 0.9 factor for max shadow density
-                diffuseColor.rgb *= (1.0 - ringColor.a * 0.9 * terminatorFade);
-              }
-            }
-          }
-          `
-        );
+        `.replace("#include <map_fragment>", ringShadowFragmentPatch);
       };
     }
 
     return mat;
-  }, [textureMap, textureRing, body.color, body.type, body.ringSystem]);
+  }, [
+    textureMap,
+    textureRing,
+    body.color,
+    body.type,
+    body.ringSystem,
+    roughness,
+    metalness,
+    sunEmissive,
+  ]);
 
   // Analytical Planet Shadow on Rings Logic
   const ringMaterial = useMemo(() => {
@@ -222,7 +204,7 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
       depthWrite: false,
       emissive: 0xffffff,
       emissiveMap: textureRing,
-      emissiveIntensity: 0.5,
+      emissiveIntensity: ringEmissive,
       roughness: 0.8,
       metalness: 0.0,
     });
@@ -230,112 +212,33 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
     mat.onBeforeCompile = (shader) => {
       mat.userData.shader = shader;
       shader.uniforms.uSunPosition = { value: new THREE.Vector3(0, 0, 0) };
+      shader.uniforms.uShadowIntensity = { value: ringShadowIntensity };
 
       // Inject uniforms and varying
       shader.vertexShader = `
         varying vec3 vPos;
         ${shader.vertexShader}
-      `.replace(
-        "#include <begin_vertex>",
-        `
-        #include <begin_vertex>
-        vPos = position;
-        `
-      );
+      `.replace("#include <begin_vertex>", planetShadowVertexPatch);
 
       shader.fragmentShader = `
         uniform vec3 uSunPosition;
+        uniform float uShadowIntensity;
         varying vec3 vPos;
         ${shader.fragmentShader}
       `
-        .replace(
-          "#include <map_fragment>",
-          `
-        #include <map_fragment>
-        
-        // Analytical Planet Shadow
-        // Ray from fragment (vPos) to Sun (uSunPosition)
-        vec3 lightDir = normalize(uSunPosition - vPos);
-        
-        // Planet is a sphere at (0,0,0) with radius 1.0 (in local space)
-        // Ray-Sphere Intersection: |O + tD|^2 = R^2
-        // (vPos + t*lightDir)^2 = 1.0^2
-        // t^2 + 2*dot(vPos, lightDir)*t + dot(vPos, vPos) - 1.0 = 0
-        
-        float b = 2.0 * dot(vPos, lightDir);
-        float c = dot(vPos, vPos) - 1.0; // Radius is 1.0
-        float delta = b*b - 4.0*c;
-        
-        // If delta > 0, line intersects sphere.
-        // We need to check if intersection is in the direction of the sun (t > 0)
-        // Since c > 0 (ring is outside planet), roots have same sign.
-        // Sum of roots = -b. If b < 0 (pointing towards planet), roots are positive.
-        
-        bool inShadow = false;
-        if (delta >= 0.0 && b < 0.0) {
-           inShadow = true;
-        }
-        
-        if (inShadow) {
-          diffuseColor.rgb = vec3(0.0);
-          // Also kill emissive if possible, but MeshStandardMaterial handles emissive separately.
-          // We can hack it by multiplying the final color? 
-          // Or just set diffuse to black, which kills the base color.
-          // Emissive is added after. To kill emissive, we might need to modify totalEmissiveRadiance.
-        }
-        `
-        )
-        .replace(
-          "#include <emissivemap_fragment>",
-          `
-        #include <emissivemap_fragment>
-        // Hack to kill emissive in shadow
-        // We need to re-calculate shadow condition or pass it?
-        // Let's just re-calculate, it's cheap.
-        
-        vec3 lDir = normalize(uSunPosition - vPos);
-        float bb = 2.0 * dot(vPos, lDir);
-        float cc = dot(vPos, vPos) - 1.0;
-        float dd = bb*bb - 4.0*cc;
-        
-        if (dd >= 0.0 && bb < 0.0) {
-          totalEmissiveRadiance = vec3(0.0);
-        }
-        `
-        );
+        .replace("#include <map_fragment>", planetShadowFragmentPatch)
+        .replace("#include <emissivemap_fragment>", planetShadowEmissivePatch);
     };
 
     return mat;
-  }, [textureRing]);
-
-  useFrame(() => {
-    if (!rotationRef.current) return;
-
-    // Update Sun Position uniform for analytical shadows
-    if (rotationRef.current) {
-      const sunWorldPos = new THREE.Vector3(0, 0, 0);
-      const meshWorldMatrix = rotationRef.current.matrixWorld;
-      const inverseMatrix = new THREE.Matrix4().copy(meshWorldMatrix).invert();
-      const sunLocalPos = sunWorldPos.applyMatrix4(inverseMatrix);
-
-      if (planetMaterial.userData.shader && textureRing) {
-        planetMaterial.userData.shader.uniforms.uSunPosition.value.copy(
-          sunLocalPos
-        );
-      }
+  }, [textureRing, ringEmissive, ringShadowIntensity]);
 
-      if (ringMaterial && ringMaterial.userData.shader) {
-        ringMaterial.userData.shader.uniforms.uSunPosition.value.copy(
-          sunLocalPos
-        );
-      }
-    }
-  });
+  const ringRef = useRef<THREE.Mesh>(null);
 
   useFrame(() => {
     if (!groupRef.current) return;
 
-    // Scaling
+    // 1. Scaling
     let s = 1;
     if (scaleMode === "didactic") {
       s = AstroPhysics.calculateDidacticRadius(body.radiusKm);
@@ -344,17 +247,59 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
     }
     groupRef.current.scale.setScalar(s);
 
-    // Rotation
-    if (rotationRef.current && body.rotationPeriodHours) {
-      const { datetime } = useStore.getState();
-      // Calculate rotation angle: (time / period) * 2PI
-      // Period is in hours, time is in ms.
-      // 1 hour = 3600000 ms
-      const currentRotation =
-        (datetime.getTime() / (body.rotationPeriodHours * 3600000)) *
-        Math.PI *
-        2;
-      rotationRef.current.rotation.y = currentRotation;
+    // 2. Rotation & Shader Uniforms
+    if (rotationRef.current) {
+      // Rotation
+      if (body.rotationPeriodHours) {
+        const { datetime } = useStore.getState();
+        const currentRotation =
+          (datetime.getTime() / (body.rotationPeriodHours * 3600000)) *
+          Math.PI *
+          2;
+        rotationRef.current.rotation.y = currentRotation;
+      }
+
+      // Shader Uniforms (Analytical Shadows)
+      if (textureRing) {
+        const sunWorldPos = new THREE.Vector3(0, 0, 0);
+
+        // A. Update Planet Material (Planet Shadow on itself / Ring Shadow on Planet)
+        // Planet is direct child of rotationRef, so use rotationRef matrix
+        if (planetMaterial.userData.shader) {
+          const meshWorldMatrix = rotationRef.current.matrixWorld;
+          const inverseMatrix = new THREE.Matrix4()
+            .copy(meshWorldMatrix)
+            .invert();
+          const sunLocalPos = sunWorldPos.clone().applyMatrix4(inverseMatrix);
+
+          planetMaterial.userData.shader.uniforms.uSunPosition.value.copy(
+            sunLocalPos
+          );
+
+          // Update Cloud Material (if exists)
+          if (cloudMaterial && cloudMaterial.userData.shader) {
+            cloudMaterial.userData.shader.uniforms.uSunPosition.value.copy(
+              sunLocalPos
+            );
+          }
+        }
+
+        // B. Update Ring Material (Planet Shadow on Ring)
+        // Ring has extra rotation, so use ringRef matrix if available
+        if (ringMaterial && ringMaterial.userData.shader && ringRef.current) {
+          const ringWorldMatrix = ringRef.current.matrixWorld;
+          const inverseRingMatrix = new THREE.Matrix4()
+            .copy(ringWorldMatrix)
+            .invert();
+          const sunLocalPosRing = sunWorldPos
+            .clone()
+            .applyMatrix4(inverseRingMatrix);
+
+          ringMaterial.userData.shader.uniforms.uSunPosition.value.copy(
+            sunLocalPosRing
+          );
+        }
+      }
     }
   });
 
@@ -391,7 +336,7 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
 
           {/* 3. Atmosphere Layer (Larger still) */}
           {body.id === "earth" && (
-            <mesh scale={[1.15, 1.15, 1.15]}>
+            <mesh scale={[1.025, 1.025, 1.025]}>
               <sphereGeometry args={[1, 64, 64]} />
               <primitive object={atmosphereMaterial} attach="material" />
             </mesh>
@@ -400,9 +345,10 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
           {/* 4. Ring System */}
           {textureRing && ringMaterial && (
             <mesh
+              ref={ringRef}
               rotation={[-Math.PI / 2, 0, 0]}
               renderOrder={1000}
-              receiveShadow
+              // receiveShadow removed to prevent double shadows (we use analytical shadows)
               // castShadow removed - using analytical shadows
             >
               <primitive
@@ -441,7 +387,14 @@ const PlanetVisual = ({ body }: { body: CelestialBody }) => {
 };
 
 // Wrapper to handle Suspense for textures/models
-const PlanetVisualWrapper = (props: { body: CelestialBody }) => {
+const PlanetVisualWrapper = (props: {
+  body: CelestialBody;
+  roughness: number;
+  metalness: number;
+  sunEmissive: number;
+  ringEmissive: number;
+  ringShadowIntensity: number;
+}) => {
   const meshRef = useRef<THREE.Mesh>(null);
   const scaleMode = useStore((state) => state.scaleMode);
   const selectId = useStore((state) => state.selectId);
@@ -470,40 +423,42 @@ const PlanetVisualWrapper = (props: { body: CelestialBody }) => {
     </mesh>
   );
 
-  if (props.body.id === "earth") {
-    return (
-      <ErrorBoundary fallback={fallback}>
-        <Suspense fallback={fallback}>
-          <Earth body={props.body} />
-        </Suspense>
-      </ErrorBoundary>
-    );
-  }
-
   // Check for 3D Model first
   if (props.body.model) {
     return (
       <ErrorBoundary fallback={fallback}>
         <Suspense fallback={fallback}>
-          <PlanetModel body={props.body} />
+          <PlanetModel
+            body={props.body}
+            roughness={props.roughness}
+            metalness={props.metalness}
+            sunEmissive={props.sunEmissive}
+            ringEmissive={props.ringEmissive}
+            ringShadowIntensity={props.ringShadowIntensity}
+          />
         </Suspense>
       </ErrorBoundary>
     );
   }
 
-  if (props.body.textures?.map) {
-    return (
-      <ErrorBoundary fallback={fallback}>
-        <Suspense fallback={fallback}>
-          <PlanetVisual {...props} />
-        </Suspense>
-      </ErrorBoundary>
-    );
-  }
-  return <PlanetVisual {...props} />;
+  return (
+    <ErrorBoundary fallback={fallback}>
+      <Suspense fallback={fallback}>
+        <PlanetVisual {...props} />
+      </Suspense>
+    </ErrorBoundary>
+  );
 };
 
-export const Planet = ({ body, children }: PlanetProps) => {
+export const Planet = ({
+  body,
+  children,
+  roughness,
+  metalness,
+  sunEmissive,
+  ringEmissive,
+  ringShadowIntensity,
+}: PlanetProps) => {
   const groupRef = useRef<THREE.Group>(null);
   const orbitLineRef = useRef<any>(null);
   const scaleMode = useStore((state) => state.scaleMode);
@@ -622,7 +577,14 @@ export const Planet = ({ body, children }: PlanetProps) => {
       )}
 
       <group ref={groupRef} name={body.id}>
-        <PlanetVisualWrapper body={body} />
+        <PlanetVisualWrapper
+          body={body}
+          roughness={roughness}
+          metalness={metalness}
+          sunEmissive={sunEmissive}
+          ringEmissive={ringEmissive}
+          ringShadowIntensity={ringShadowIntensity}
+        />
 
         {/* 
           Moons usually orbit the planet's equatorial plane (which is tilted).
